/**
 * Phase 1 Improvement Tests
 * Tests for critical fixes implemented in Phase 1
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { signal, computed, effect, resource } from '../../src/index.js';
import { batch, createRoot } from '../../src/core/reactive/batch.js';

describe('Phase 1 Improvements', () => {
  let dispose: (() => void) | undefined;

  afterEach(() => {
    dispose?.();
    dispose = undefined;
  });

  describe('Topological Sorting and Execution Order', () => {
    it('should execute computeds in correct dependency order', () => {
      const log: string[] = [];
      
      createRoot(d => {
        dispose = d;
        
        const source = signal(1);
        
        const level1 = computed(() => {
          const value = source() * 2;
          log.push(`level1: ${value}`);
          return value;
        });
        
        const level2 = computed(() => {
          const value = level1() + 10;
          log.push(`level2: ${value}`);
          return value;
        });
        
        const level3 = computed(() => {
          const value = level2() * 2;
          log.push(`level3: ${value}`);
          return value;
        });
        
        effect(() => {
          const value = level3();
          log.push(`effect: ${value}`);
        });
        
        // Clear initial setup logs
        log.length = 0;
        
        // Update source
        source.set(2);
        
        // Should execute in dependency order: level1 -> level2 -> level3 -> effect
        expect(log).toEqual([
          'level1: 4',
          'level2: 14',
          'level3: 28',
          'effect: 28'
        ]);
      });
    });
    
    it('should handle diamond dependency graphs correctly', () => {
      const log: string[] = [];
      
      createRoot(d => {
        dispose = d;
        
        const source = signal(1);
        
        // Diamond pattern:
        //     source
        //     /    \
        //   left   right
        //     \    /
        //     result
        
        const left = computed(() => {
          const value = source() * 2;
          log.push(`left: ${value}`);
          return value;
        });
        
        const right = computed(() => {
          const value = source() * 3;
          log.push(`right: ${value}`);
          return value;
        });
        
        const result = computed(() => {
          const value = left() + right();
          log.push(`result: ${value}`);
          return value;
        });
        
        effect(() => {
          const value = result();
          log.push(`effect: ${value}`);
        });
        
        // Clear initial setup logs
        log.length = 0;
        
        // Update source
        source.set(2);
        
        // Both left and right should run before result
        const leftIndex = log.indexOf('left: 4');
        const rightIndex = log.indexOf('right: 6');
        const resultIndex = log.indexOf('result: 10');
        const effectIndex = log.indexOf('effect: 10');
        
        expect(leftIndex).toBeLessThan(resultIndex);
        expect(rightIndex).toBeLessThan(resultIndex);
        expect(resultIndex).toBeLessThan(effectIndex);
      });
    });
    
    it('should not duplicate effect runs in sync context', () => {
      const runs: number[] = [];
      
      createRoot(d => {
        dispose = d;
        
        const a = signal(1);
        const b = computed(() => a() * 2);
        const c = computed(() => b() + 1);
        
        effect(() => {
          runs.push(c());
        });
        
        // Should run once initially
        expect(runs).toEqual([3]);
        
        // Clear runs
        runs.length = 0;
        
        // Update signal
        a.set(2);
        
        // Should run exactly once, not twice
        expect(runs).toEqual([5]);
        
        // Update again
        a.set(3);
        
        // Should have run once more
        expect(runs).toEqual([5, 7]);
      });
    });
    
    it('should handle batch updates with correct ordering', () => {
      const log: string[] = [];
      
      createRoot(d => {
        dispose = d;
        
        const a = signal(1);
        const b = signal(2);
        const c = signal(3);
        
        const sum = computed(() => {
          const value = a() + b() + c();
          log.push(`sum: ${value}`);
          return value;
        });
        
        const product = computed(() => {
          const value = a() * b() * c();
          log.push(`product: ${value}`);
          return value;
        });
        
        const combined = computed(() => {
          const value = sum() + product();
          log.push(`combined: ${value}`);
          return value;
        });
        
        effect(() => {
          const value = combined();
          log.push(`effect: ${value}`);
        });
        
        // Clear initial logs
        log.length = 0;
        
        // Batch multiple updates
        batch(() => {
          a.set(2);
          b.set(3);
          c.set(4);
        });
        
        // Each computed should only run once
        const sumCount = log.filter(l => l.startsWith('sum:')).length;
        const productCount = log.filter(l => l.startsWith('product:')).length;
        const combinedCount = log.filter(l => l.startsWith('combined:')).length;
        const effectCount = log.filter(l => l.startsWith('effect:')).length;
        
        expect(sumCount).toBe(1);
        expect(productCount).toBe(1);
        expect(combinedCount).toBe(1);
        expect(effectCount).toBe(1);
        
        // And the final values should be correct
        expect(log).toContain('sum: 9');      // 2 + 3 + 4
        expect(log).toContain('product: 24');  // 2 * 3 * 4
        expect(log).toContain('combined: 33'); // 9 + 24
        expect(log).toContain('effect: 33');
      });
    });
  });
  
  describe('Resource Loading State', () => {
    it('should set loading state synchronously when dependencies change', async () => {
      await createRoot(async d => {
        dispose = d;
        
        const trigger = signal(1);
        let fetchCount = 0;
        
        const res = resource(async () => {
          const id = trigger(); // Track dependency
          fetchCount++;
          await new Promise(r => setTimeout(r, 10));
          return { id, count: fetchCount };
        });
        
        // Initial state should be loading
        expect(res.loading()).toBe(true);
        
        // Wait for initial load
        await new Promise(r => setTimeout(r, 20));
        expect(res.loading()).toBe(false);
        expect(res()?.id).toBe(1);
        expect(res()?.count).toBe(1);
        
        // Change dependency
        trigger.set(2);
        
        // Loading should be set synchronously
        expect(res.loading()).toBe(true);
        
        // Wait for fetch to complete
        await new Promise(r => setTimeout(r, 20));
        expect(res.loading()).toBe(false);
        expect(res()?.id).toBe(2);
        expect(res()?.count).toBe(2);
      });
    });
    
    it('should handle rapid dependency changes', async () => {
      await createRoot(async d => {
        dispose = d;
        
        const id = signal(1);
        let resolveCount = 0;
        
        const res = resource(async () => {
          const currentId = id();
          await new Promise(r => setTimeout(r, 10));
          resolveCount++;
          return { id: currentId, resolved: resolveCount };
        });
        
        // Rapid changes
        id.set(2);
        expect(res.loading()).toBe(true);
        
        id.set(3);
        expect(res.loading()).toBe(true);
        
        id.set(4);
        expect(res.loading()).toBe(true);
        
        // Wait for final fetch
        await new Promise(r => setTimeout(r, 30));
        
        // Should only have the last value
        expect(res()?.id).toBe(4);
        expect(res.loading()).toBe(false);
      });
    });
    
    it('should set loading state correctly with complex dependencies', async () => {
      await createRoot(async d => {
        dispose = d;
        
        const userId = signal(1);
        const includeDetails = signal(false);
        
        const res = resource(async () => {
          const id = userId();
          const details = includeDetails();
          
          await new Promise(r => setTimeout(r, 10));
          
          return {
            id,
            name: `User ${id}`,
            details: details ? { email: `user${id}@example.com` } : null
          };
        });
        
        // Wait for initial load
        await new Promise(r => setTimeout(r, 20));
        expect(res.loading()).toBe(false);
        expect(res()?.id).toBe(1);
        expect(res()?.details).toBe(null);
        
        // Change one dependency
        includeDetails.set(true);
        expect(res.loading()).toBe(true);
        
        await new Promise(r => setTimeout(r, 20));
        expect(res.loading()).toBe(false);
        expect(res()?.details).toEqual({ email: 'user1@example.com' });
        
        // Change both dependencies
        batch(() => {
          userId.set(2);
          includeDetails.set(false);
        });
        
        expect(res.loading()).toBe(true);
        
        await new Promise(r => setTimeout(r, 20));
        expect(res.loading()).toBe(false);
        expect(res()?.id).toBe(2);
        expect(res()?.details).toBe(null);
      });
    });
  });
  
  describe('Error Handling in Cleanup', () => {
    it('should handle errors in cleanup functions without breaking disposal', () => {
      const cleanupLog: string[] = [];
      const errorLog: string[] = [];
      
      // Mock console.error
      const originalError = console.error;
      console.error = (msg: string, error?: any) => {
        errorLog.push(msg);
      };
      
      try {
        createRoot(d => {
          dispose = d;
          
          const s = signal(1);
          
          // Effect 1 with failing cleanup
          effect(() => {
            s();
            return () => {
              cleanupLog.push('cleanup1');
              throw new Error('Cleanup 1 failed');
            };
          });
          
          // Effect 2 with successful cleanup
          effect(() => {
            s();
            return () => {
              cleanupLog.push('cleanup2');
            };
          });
          
          // Effect 3 with failing cleanup
          effect(() => {
            s();
            return () => {
              cleanupLog.push('cleanup3');
              throw new Error('Cleanup 3 failed');
            };
          });
          
          // Trigger update to run cleanups
          s.set(2);
        });
        
        // Dispose to run remaining cleanups
        dispose?.();
        
        // All cleanups should have been attempted
        expect(cleanupLog).toContain('cleanup1');
        expect(cleanupLog).toContain('cleanup2');
        expect(cleanupLog).toContain('cleanup3');
        
        // Errors should have been logged
        expect(errorLog.some(msg => msg.includes('cleanup'))).toBe(true);
        
      } finally {
        console.error = originalError;
      }
    });
    
    it('should handle errors in nested owner disposal', () => {
      const cleanupLog: string[] = [];
      const errorLog: string[] = [];
      
      // Mock console.error
      const originalError = console.error;
      console.error = (msg: string, error?: any) => {
        errorLog.push(msg);
      };
      
      try {
        createRoot(d => {
          dispose = d;
          
          // Parent effect
          effect(() => {
            // Child effect with error in cleanup
            effect(() => {
              return () => {
                cleanupLog.push('child-cleanup');
                throw new Error('Child cleanup failed');
              };
            });
            
            return () => {
              cleanupLog.push('parent-cleanup');
            };
          });
        });
        
        // Dispose everything
        dispose?.();
        
        // Both cleanups should have been attempted
        expect(cleanupLog).toContain('child-cleanup');
        expect(cleanupLog).toContain('parent-cleanup');
        
        // Error should have been logged but not propagated
        expect(errorLog.some(msg => msg.includes('cleanup'))).toBe(true);
        
      } finally {
        console.error = originalError;
      }
    });
    
    it('should continue disposing children after one fails', () => {
      const disposeLog: string[] = [];
      const errorLog: string[] = [];
      
      // Mock console.error
      const originalError = console.error;
      console.error = (msg: string, error?: any) => {
        errorLog.push(msg);
      };
      
      try {
        createRoot(d => {
          dispose = d;
          
          // Create multiple effects
          for (let i = 0; i < 5; i++) {
            effect(() => {
              const id = i;
              return () => {
                disposeLog.push(`dispose-${id}`);
                if (id === 2) {
                  throw new Error(`Disposal ${id} failed`);
                }
              };
            });
          }
        });
        
        // Dispose everything
        dispose?.();
        
        // All disposals should have been attempted
        expect(disposeLog).toHaveLength(5);
        expect(disposeLog).toContain('dispose-0');
        expect(disposeLog).toContain('dispose-1');
        expect(disposeLog).toContain('dispose-2');
        expect(disposeLog).toContain('dispose-3');
        expect(disposeLog).toContain('dispose-4');
        
        // Only one error should have been logged
        const cleanupErrors = errorLog.filter(msg => msg.includes('cleanup'));
        expect(cleanupErrors.length).toBeGreaterThan(0);
        
      } finally {
        console.error = originalError;
      }
    });
  });
  
  describe('Integration Tests', () => {
    it('should handle complex reactive graph with all improvements', () => {
      const log: string[] = [];
      
      createRoot(d => {
        dispose = d;
        
        const config = signal({ theme: 'dark', lang: 'en' });
        const user = signal({ name: 'John', age: 30 });
        
        const userDisplay = computed(() => {
          const u = user();
          const display = `${u.name} (${u.age})`;
          log.push(`userDisplay: ${display}`);
          return display;
        });
        
        const configDisplay = computed(() => {
          const c = config();
          const display = `${c.theme}/${c.lang}`;
          log.push(`configDisplay: ${display}`);
          return display;
        });
        
        const combined = computed(() => {
          const result = `${userDisplay()} - ${configDisplay()}`;
          log.push(`combined: ${result}`);
          return result;
        });
        
        effect(() => {
          const value = combined();
          log.push(`effect: ${value}`);
        });
        
        // Clear initial logs
        log.length = 0;
        
        // Batch update both signals
        batch(() => {
          config.set({ theme: 'light', lang: 'fr' });
          user.set({ name: 'Jane', age: 25 });
        });
        
        // Should update in correct order and only once each
        expect(log).toEqual([
          'userDisplay: Jane (25)',
          'configDisplay: light/fr',
          'combined: Jane (25) - light/fr',
          'effect: Jane (25) - light/fr'
        ]);
      });
    });
    
    it('should handle async resources with proper cleanup and ordering', async () => {
      await createRoot(async d => {
        dispose = d;
        
        const id = signal(1);
        const loadLog: string[] = [];
        let activeRequests = 0;
        
        const res = resource(async () => {
          const currentId = id();
          activeRequests++;
          loadLog.push(`start-${currentId}`);
          
          try {
            await new Promise(r => setTimeout(r, 10));
            loadLog.push(`complete-${currentId}`);
            return { id: currentId, data: `Data ${currentId}` };
          } finally {
            activeRequests--;
          }
        });
        
        // Effect to track loading state changes
        const loadingStates: boolean[] = [];
        effect(() => {
          loadingStates.push(res.loading());
        });
        
        // Initial load
        expect(res.loading()).toBe(true);
        expect(activeRequests).toBe(1);
        
        await new Promise(r => setTimeout(r, 20));
        expect(res.loading()).toBe(false);
        expect(res()?.id).toBe(1);
        expect(activeRequests).toBe(0);
        
        // Rapid changes
        id.set(2);
        id.set(3);
        id.set(4);
        
        // Should be loading
        expect(res.loading()).toBe(true);
        
        await new Promise(r => setTimeout(r, 50));
        
        // Should have completed with last value
        expect(res.loading()).toBe(false);
        expect(res()?.id).toBe(4);
        expect(activeRequests).toBe(0);
        
        // Check that loading state was properly managed
        expect(loadingStates.includes(true)).toBe(true);
        expect(loadingStates.includes(false)).toBe(true);
      });
    });
  });
});